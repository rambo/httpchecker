<h1>URL checker</h1>

<p>Reads a YAML config file for urls to check against given rules, then checks them periodically and logs the results to sqlite database/logfile.</p>

<h1>Installing</h1>

<ol>
<li>Prepare a new virtualenv</li>
<li>unpack the archive</li>
<li>pip install -r requirements.txt</li>
</ol>

<h1>running</h1>

<p>./main.py example.yml [check_interval]</p>

<p>The process will keep in foreground until interrupted by appropriate signal, check_interval is in seconds, the default is 15.</p>

<h1>Configuration format</h1>

<p>This is YAML file, the first level must be a dictionary. Second level can be either list (just plain URLs) or dictionary (URLs with content checks), if the second level is dictionary the third level must be a list of regular expressions to test against the fetched source.</p>

<h1>Log format</h1>

<p>The log is sqlite database (for especially read/search performance reasons) with the following tables</p>

<h2>sessions</h2>

<p>The main entry point, everything else depends on this</p>

<h3>sessions.time</h3>

<p>Millisecond accuracy timestamp.</p>

<h3>sessions.groupkey</h3>

<p>The grouping key from the configuration file</p>

<h3>sessions.url</h3>

<p>The URL this session refers to (in case the same URL has for example multiple content checks)</p>

<h3>sessions.allok</h3>

<p>High-level view whether this session was fine or not.</p>

<h2>status</h2>

<p>The general status table, shows response times, http/io error codes and if there were any issues with content checks</p>

<h3>status.sessionid</h3>

<p>Foreign key to the sessions table (to get url and group)</p>

<h3>status.time</h3>

<p>A separate timestamp for the status entry, to avoid JOINs if we want to just do some time-based analysis on these.</p>

<h3>status.responsetime</h3>

<p>Response time in milliseconds </p>

<h3>status.ioerror</h3>

<p>If there was an IO error the code is stored here, NULL if not applicable.</p>

<h3>status.httpstatus</h3>

<p>HTTP status code, NULL if not applicable (In case of IOError for example)</p>

<h2>status.contentstatus</h2>

<p>Boolean value indicating whether all of the content checks were ok, NULL if not applicable (no content-checks defined, or we did not get a body to check against)</p>

<h2>contenterror</h2>

<p>This just list the regexes that failed.</p>

<h3>contenterror.time</h3>

<p>A separate timestamp for the contenterror entry, to avoid JOINs if we want to just do some time-based analysis on these.</p>

<h3>contenterror.sessionid</h3>

<p>Foreign key to the sessions table (to get url and group)</p>

<h3>contenterror.testregex</h3>

<p>The regex from config file that failed.</p>

<h2>contenthistory</h2>

<p>Contains the HTML snapshot of the site during the check time.</p>

<h3>contenthistory.time</h3>

<p>A separate timestamp for the contenterror entry, to avoid JOINs if we want to just do some time-based analysis on these.</p>

<h3>contenthistory.sessionid</h3>

<p>Foreign key to the sessions table (to get url and group)</p>

<h3>contenthistory.html</h3>

<p>The source HTML.</p>
